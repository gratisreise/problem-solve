from collections import deque
import sys

input = sys.stdin.readline

# 입력 처리
N, K = map(int, input().split())
MAX = 500001  # 최대 위치 범위

# 방문 배열: [짝수 시간, 홀수 시간]에 도달한 최소 시간
visited = [[-1] * 2 for _ in range(MAX)]

# BFS
queue = deque([(N, 0)])  # (위치, 시간)
visited[N][0] = 0  # 초기 위치, 시간 0

while queue:
    x, t = queue.popleft()
    
    # 동생의 현재 위치 계산
    delta = t * (t + 1) // 2  # 1+2+...+t
    if K + delta > 500000:  # 동생 위치가 범위 초과
        break
    if visited[K + delta][t % 2] != -1:  # 동생 위치 방문 완료
        print(t)
        sys.exit(0)
    
    # 이동: X-1, X+1, 2*X
    for nx in (x-1, x+1, 2*x):
        if 0 <= nx < MAX and visited[nx][(t+1) % 2] == -1:
            visited[nx][(t+1) % 2] = t + 1
            queue.append((nx, t + 1))

# 동생을 못 찾으면 -1
print(-1)

"""
문제 분석
입력:
    N: 수빈이의 초기 위치 (0 ≤ N ≤ 500,000).
    K: 동생의 초기 위치 (0 ≤ K ≤ 500,000).
조건:
    수빈이 이동:
        걷기: X-1, X+1 (1초).
        순간이동: 2*X (1초).
        범위: 0 ≤ X ≤ 500,000.
    동생 이동:
        매 초 이동 거리 증가 (1, 2, 3, ...).
        위치: K + t*(t+1)/2 (t초 후).
    목표: 수빈이가 동생을 만나는 최소 시간, 불가능하면 -1.
출력: 최소 시간 또는 -1.

접근법
    BFS: 수빈이의 이동을 BFS로 탐색.
    동생 위치 계산: 동생의 위치는 시간에 따라 결정적이므로 각 시간마다 체크.
    최적화: 동일 위치에서 시간의 주기성 활용 (짝수/홀수 시간).

코드 설명
입력 처리:
    N, K: 수빈이와 동생의 초기 위치.
    MAX: 최대 범위 500,001.
배열 초기화:
    visited: 각 위치에 도달하는 최소 시간 ([짝수 시간, 홀수 시간]).
    초기값 -1 (미방문).
BFS:
    초기: (N, 0)에서 시작.
    visited[N][0] = 0.
    큐에서 (x, t) 꺼내 이동 계산:
        x-1, x+1, 2*x.
    조건:
        범위 내 (0 ≤ nx < MAX).
        다음 시간의 짝수/홀수 방문 여부 확인 (visited[nx][(t+1) % 2]).
    방문 시: 시간 기록, 큐에 추가.
동생 위치 체크:
    delta = t * (t + 1) // 2: t초 후 동생의 이동 거리.
    K + delta: 동생의 현재 위치.
    범위 초과 시 종료.
    visited[K + delta][t % 2] != -1: 동생 위치에 수빈이가 이미 도달했으면 종료.
출력:
    동생을 찾으면 t 출력 후 종료.
    못 찾으면 -1.

시간 복잡도
    BFS: 각 위치를 최대 두 번(짝수/홀수) 방문 → O(MAX) ≈ O(5×10⁵).
    이동 연산: O(1) (3가지).
    총: O(10⁶) ≈ 0.25초 내 충분 (파이썬 약 10⁷ 연산 가능).
공간 복잡도
    visited: MAX × 2 × 4바이트 ≈ 4MB.
    queue: 최악 O(MAX) ≈ 2MB.
    총: 약 6MB (512MB 제한 내 여유).

최적화 포인트
    짝수/홀수 방문 배열: 동생 위치가 시간에 따라 주기적으로 변하므로, 각 위치를 최대 두 번만 체크.
    조기 종료: 동생 위치 초과 시 탐색 중단.

    왜 이렇게 되는가?
1. 수빈이의 이동 주기성
    수빈이가 BFS로 위치 X에 최소 시간 t에 도달했다고 해보자.
    예: X=10, t=2 (짝수 시간).
    수빈이는 이동 규칙(X-1, X+1, 2*X) 때문에, 한 번 X에 도달한 뒤에는 2초 주기로 X에 다시 올 수 있어:
        t=2 → 10+1=11 (t=3) → 11-1=10 (t=4).
        즉, t=4, t=6, t=8, ... (짝수 시간)에 계속 10에 올 수 있음.
    홀수 시간도 마찬가지: t=3에 도달하면 t=5, t=7, ... 가능.
2. 동생의 이동
    동생의 위치는 시간 t에 따라 결정적: K + t*(t+1)/2.
    동생이 특정 위치 X에 도달하는 시간 t'를 계산할 수 있음 (단, X = K + t'*(t'+1)/2).
    중요한 건 t'의 짝수/홀수 여부야.
3. 만나는 조건
    수빈이가 X에 최소 시간 t에 도달했는데, 동생이 X에 나중에 t'에 도달한다고 해보자.
    만약 t와 t'의 패리티(짝수/홀수)가 같다면:
        t' ≥ t이고, t'-t가 짝수라서, 수빈이는 t에서 t'까지 2초 단위로 기다릴 수 있어.
        예: t=2, t'=6 → 수빈이는 4초 기다리면 됨.
    패리티가 다르면:
        t'-t가 홀수라서, 수빈이가 정확히 t'에 X에 있을 수 없음.
4. BFS에서 한 번에 해결
    수빈이의 BFS를 돌면서 각 위치 X에 도달하는 최소 짝수 시간(visited[X][0])과 최소 홀수 시간(visited[X][1])을 기록해.
    BFS 중에 현재 시간 t에서 동생 위치 K + delta를 계산하고, visited[K + delta][t % 2] != -1이면:
        수빈이가 이미 그 위치에 같은 패리티로 도달한 적이 있으니까, t에 만날 수 있다는 뜻.
    그러니까 동생의 위치를 별도로 BFS로 탐색하거나, 시간마다 일일이 비교할 필요 없이, 수빈이의 BFS 한 번으로 모든 가능성을 체크할 수 있어.
"""