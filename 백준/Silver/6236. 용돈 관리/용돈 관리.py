# 입력 처리
n, m = map(int, input().split())
a = [int(input()) for _ in range(n)]

# 초기 설정
mx = max(a)  # 최대 일일 사용 금액
lo, hi = mx, 1000000004  # 탐색 범위
ret = 0

# 인출 금액 가능 여부 체크
def check(mid):
    cnt = 1       # 인출 횟수 (첫 인출 시작)
    temp = mid    # 현재 남은 금액
    for i in range(n):
        if mid - a[i] < 0:  # 현재 금액으로 부족하면 새 인출
            mid = temp
            cnt += 1
        mid -= a[i]  # 일일 사용 금액만큼 감소
    return cnt <= m  # 인출 횟수가 m 이하인지

# 이진 탐색
while lo <= hi:
    mid = (lo + hi) // 2
    if check(mid):  # 가능하면 더 작은 금액 탐색
        hi = mid - 1
        ret = mid
    else:           # 불가능하면 더 큰 금액 탐색
        lo = mid + 1

# 결과 출력
print(ret)
"""
코드 설명
1. 입력 처리
* 입력:
    * n, m: 일수 (1 ≤ N ≤ 100,000), 인출 횟수 (1 ≤ M ≤ N).
    * a: N일 동안의 일일 사용 금액 리스트 (1 ≤ a[i] ≤ 10,000).
        * 리스트 컴프리헨션으로 입력받음.
2. 초기 설정
* mx: 최대 일일 사용 금액 (탐색 하한, 각 인출은 최소 이 값 이상이어야 함).
* lo, hi: 이진 탐색 범위 (mx ~ 10^9 + 4, 문제 조건 상 충분히 큰 상한).
* ret: 최소 인출 금액 저장.
3. 인출 금액 체크 (check 함수)
* 역할: 주어진 금액 mid로 M번 이하 인출로 N일을 커버할 수 있는지 확인.
* 흐름:
    * cnt = 1: 인출 횟수, 첫 인출로 시작.
    * temp = mid: 초기 인출 금액 저장.
    * 각 날짜 순회:
        * mid - a[i] < 0: 현재 금액으로 부족하면 새 인출 (cnt += 1, mid = temp).
        * mid -= a[i]: 일일 사용 금액만큼 감소.
    * return cnt <= m: 인출 횟수가 M 이하인지 반환.
4. 이진 탐색
* 역할: 최소 인출 금액 K 탐색.
* 흐름:
    * while lo <= hi: 범위 내에서 반복.
        * mid = (lo + hi) // 2: 중간값 계산.
        * check(mid):
            * True: 가능 → 더 작은 금액 탐색 (hi = mid - 1), ret = mid.
            * False: 불가능 → 더 큰 금액 탐색 (lo = mid + 1).
5. 결과 출력
* ret: 최소 인출 금액 K 출력.

문제 분석
* 문제: 백준 6236 "용돈 관리".
* 입력:
    * N, M: 일수, 인출 횟수.
    * N개의 일일 사용 금액.
* 조건:
    * N일 동안 사용할 돈을 M번 인출.
    * 각 인출 금액 K는 동일, 최소화해야 함.
    * 하루 사용 금액은 K 이내여야 함.
* 출력: 최소 인출 금액 K.

시간 복잡도
* 입력: O(N) (≈ 10^5).
* 초기 최대값 계산: O(N) (≈ 10^5).
* 이진 탐색:
    * 범위: log(10^9) (≈ 30).
    * check: O(N) per 호출.
    * 총합: O(N log(10^9)) (≈ 3×10^6).
* 총합: O(N log(10^9)).
* 결과: 2초 내 충분 (10^8 대비 여유).

공간 복잡도
* a: O(N) ≈ 0.4MB (N ≤ 10^5).
* 총합: 약 0.4MB (128MB 내 여유).

결론
* 정확성: C++ 코드와 동일한 로직, 샘플 통과.
* 효율성: 시간 O(N log(10^9)), 공간 O(N)으로 최적.
* 특징:
    * 이진 탐색으로 최소 K 효율적 탐색.
    * check 함수로 인출 횟수 판별.
* 검증: N, M 범위 내 효율적 동작.
"""