import sys
input = sys.stdin.readline

# 입력
n = int(input())
INF = 987654321
dp = [INF] * (1000004)  # DP 배열, INF로 초기화
dp[1] = 0  # 1은 0번 연산

# DP 계산
for i in range(1, n + 1):
    if i % 3 == 0:
        dp[i] = min(dp[i // 3] + 1, dp[i])
    if i % 2 == 0:
        dp[i] = min(dp[i // 2] + 1, dp[i])
    dp[i] = min(dp[i - 1] + 1, dp[i])

# 경로 추적 함수
def go(here):
    if here == 0:  # 0에 도달하면 종료 (실제로는 1에서 끝남)
        return
    print(here, end=" ")
    if here % 3 == 0 and dp[here] == dp[here // 3] + 1:
        go(here // 3)
    elif here % 2 == 0 and dp[here] == dp[here // 2] + 1:
        go(here // 2)
    elif here - 1 >= 0 and dp[here] == dp[here - 1] + 1:
        go(here - 1)

# 출력
print(dp[n])  # 최소 연산 횟수
go(n)  # 경로 출력
"""
문제 접근 방법과 아이디어
문제 이해
* 목표: N을 1로 만드는 최소 연산 횟수와 연산 경로 출력.
* 조건:
    * 사용 가능한 연산:
        * 3으로 나누기 (N % 3 == 0).
        * 2로 나누기 (N % 2 == 0).
        * 1 빼기.
    * 입력: N (1 ≤ N ≤ 10^6).
    * 출력: 최소 횟수, 경로 (N에서 1까지의 수열).
접근 아이디어
* DP 정의:
    * dp[i]: i를 1로 만드는 최소 연산 횟수.
* 점화식:
    * dp[i] = min(dp[i-1] + 1, dp[i/2] + 1 (if i % 2 == 0), dp[i/3] + 1 (if i % 3 == 0)).
    * 초기: dp[1] = 0, 나머지는 무한대(INF).
* 경로 추적:
    * 재귀 함수로 역추적: 현재 값에서 이전 값으로 이동 조건 확인.
    * 조건: dp[here] == dp[next] + 1을 만족하는 연산 선택.
* 구현 전략:
    * Bottom-up DP로 최소 횟수 계산.
    * Top-down 재귀로 경로 출력.

    코드 설명
1. 입력 처리
* n: 입력값 (1 ≤ N ≤ 10^6).
* INF: 무한대 값 (987654321).
* dp: 1000004 크기 배열, INF로 초기화, dp[1] = 0.
2. DP 계산
* i: 1부터 n까지 순회.
* 연산 적용:
    * i % 3 == 0: dp[i/3] + 1과 비교.
    * i % 2 == 0: dp[i/2] + 1과 비교.
    * 항상: dp[i-1] + 1과 비교.
* dp[i]를 최소값으로 갱신.
3. 경로 추적 함수 (go)
* here: 현재 값.
* 기저: here == 0 (실제로는 1에서 종료).
* 출력: 현재 값 출력.
* 다음 이동:
    * here % 3 == 0이고 dp[here] == dp[here/3] + 1: 3으로 나눔.
    * here % 2 == 0이고 dp[here] == dp[here/2] + 1: 2로 나눔.
    * here - 1 >= 0이고 dp[here] == dp[here-1] + 1: 1 뺌.
* 재귀 호출로 경로 추적.
4. 출력
* dp[n]: 최소 연산 횟수.
* go(n): N에서 1까지 경로 출력.

문제 분석
* 문제: 백준 12852 "1로 만들기 2".
* 입력: N (1 ≤ N ≤ 10^6).
* 출력: 최소 연산 횟수, 경로 (공백 구분).
* 조건: 3 나누기, 2 나누기, 1 빼기 사용.

시간 복잡도
* DP 계산: O(N) (N ≤ 10^6).
* 경로 추적: O(log N) (최대 연산 횟수).
* 총합: O(N), 1초 내 충분.

공간 복잡도
* dp: O(N) ≈ 4MB.
* 총합: O(N) (128MB 내 여유).

결론
* 정확성: DP로 최소 횟수 계산, 재귀로 경로 추적.
* 효율성: 시간 O(N), 공간 O(N).
* 아이디어: Bottom-up DP + Top-down 경로 출력.
"""