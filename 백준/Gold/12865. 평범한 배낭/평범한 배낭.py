import sys

n, k = map(int, input().split())

dp = [0] * (k + 1)

for _ in range(n):
    w, v = map(int, input().split())
    for j in range(k, w - 1, -1):
        dp[j] = max(dp[j], dp[j - w] + v)
print(dp[k])

"""
문제 접근 방법과 아이디어
문제 이해
* 목표: N개 물건과 무게 제한 K로 얻을 수 있는 최대 가치 계산.
* 조건:
    * 물건: N개 (무게 W, 가치 V).
    * 무게 제한: K (1 ≤ K ≤ 100,000).
    * 각 물건은 한 번만 사용 가능 (0/1 Knapsack).
접근 아이디어
* DP 정의:
    * dp[j]: 무게 j까지 담았을 때 얻을 수 있는 최대 가치.
* 점화식:
    * dp[j] = max(dp[j], dp[j - w] + v) (w는 물건 무게, v는 가치).
    * 초기: dp[0] = 0, 나머지는 0 (최대값 갱신이므로 초기화 필요 없음).
* 구현 전략:
    * 1차원 DP 배열 사용, 뒤에서부터 갱신 (중복 사용 방지).
    * 각 물건에 대해, K부터 w까지 역순으로 순회하며 최대 가치 갱신.
    * Bottom-up 방식으로 계산.
* 결과:
    * dp[k]: 무게 K로 얻을 수 있는 최대 가치.


코드 설명
1. 입력 처리
* n, k: 물건 수(N), 무게 제한(K).
* dp: 크기 K+1 배열, 0으로 초기화.
2. 물건 입력 및 DP 계산
* 반복 N번: 각 물건 입력.
    * w, v: 무게와 가치.
    * j: K부터 w까지 역순으로 순회.
    * dp[j] = max(dp[j], dp[j - w] + v): j 무게에서 현재 물건 사용 여부 비교.
3. 출력
* dp[k]: 무게 K로 얻을 수 있는 최대 가치 출력.

문제 분석
* 문제: 백준 12865 "평범한 배낭".
* 입력: N, K, N개의 물건 (무게, 가치).
* 출력: K 무게로 얻을 수 있는 최대 가치.
* 조건: 각 물건 한 번만 사용 가능.

점화식 자세한 설명
점화식: dp[j] = max(dp[j], dp[j - w] + v)
* 의미:
    * 무게 j로 얻을 수 있는 최대 가치는, 기존 값(dp[j])과 "w 무게 물건을 사용했을 때의 최대 가치"(dp[j - w] + v) 중 큰 값.
* 초기:
    * dp[0] = 0: 무게 0으로 0 가치.
* 동작:
    * dp[j - w]: w 무게를 사용하기 전의 최대 가치.
    * w 물건 추가 → 가치 v 증가 → dp[j - w] + v.
    * max()로 더 큰 값 선택.
역순 순회의 이유
* 중복 방지:
    * 정방향으로 갱신하면 같은 물건을 여러 번 사용할 수 있음 (무한 배낭 문제처럼).
    * 역순으로 하면, 현재 물건을 고려하기 전의 값(dp[j - w])만 참조 → 0/1 조건 만족.
* 예:
    * 순방향: dp[10] = dp[5] + v 후, dp[15] = dp[10] + v → 동일 물건 중복.
    * 역순: dp[10] 갱신 시 dp[5]는 이전 상태 유지 → 중복 없음.
"""