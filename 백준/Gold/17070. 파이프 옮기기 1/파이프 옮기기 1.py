import sys
input = sys.stdin.readline

def check(y, x, d):
    if x <= n and y <= n:
        if d == 0 or d == 2:
            if a[y][x] == 0:
                return True
        if d == 1:
            if a[y][x] == 0 and a[y-1][x] == 0 and a[y][x-1]== 0:
                return True
    return False

n = int(input())
a = [[0]*(n+1)] + [[0] + list(map(int, input().split())) for _ in range(n)]
dp = [[[0]*3 for _ in range(n+1)] for _ in range(n+1)]

dp[1][2][0] = 1

for i in range(1, n + 1):
    for j in range(1, n + 1):
        # 가로(0)에서 가능한 이동
        if check(i, j+1, 0):
            dp[i][j+1][0] += dp[i][j][0]
        if check(i+1, j+1, 1):
            dp[i+1][j+1][1] += dp[i][j][0]
        
        # 세로(2)에서 가능한 이동
        if check(i+1, j, 2):
            dp[i+1][j][2] += dp[i][j][2]
        if check(i+1, j+1, 1):
            dp[i+1][j+1][1] += dp[i][j][2]
        
        # 대각선(1)에서 가능한 이동
        if check(i, j+1, 0):
            dp[i][j+1][0] += dp[i][j][1]
        if check(i+1, j, 2):
            dp[i+1][j][2] += dp[i][j][1]
        if check(i+1, j+1, 1):
            dp[i+1][j+1][1] += dp[i][j][1]

ret = dp[n][n][0] + dp[n][n][1] + dp[n][n][2]
print(ret)

"""
문제 접근 방법과 아이디어
문제 이해
* 목표: (1,1)에서 (N,N)까지 파이프를 이동시키는 방법의 수를 구한다.
* 조건:
    * 파이프는 가로, 세로, 대각선 3가지 상태로 이동 가능.
    * 이동 시 벽(1)을 피해야 하며, 대각선 이동은 추가로 위와 왼쪽 칸도 비어 있어야 함.
    * 집은 N×N 격자, 시작은 (1,1)-(1,2) 가로 상태.
접근 아이디어
* 동적 계획법(DP) 선택:
    * 파이프 끝점의 위치와 방향에 따라 이동 경로가 결정되므로, 각 상태에서의 경우의 수를 DP로 계산.
    * 상태 정의: (y, x, 방향)에서 (N,N)에 도달하는 방법 수.
* 방향 정의:
    * 0: 가로, 1: 대각선, 2: 세로.
    * 각 방향에서 가능한 다음 이동:
        * 가로 → 가로(오른쪽), 대각선(오른쪽 아래).
        * 세로 → 세로(아래), 대각선(오른쪽 아래).
        * 대각선 → 가로(오른쪽), 세로(아래), 대각선(오른쪽 아래).
* 점화식:
    * dp[y][x][d]: (y,x)에 방향 d로 도달하는 방법 수.
    * 이동 가능 여부를 체크하며 이전 상태에서 값을 누적.
* 초기 조건:
    * 시작점 (1,2)에 가로로 놓임: dp[1][2][0] = 1.
* 최종 결과:
    * (N,N)에 가로, 세로, 대각선으로 도달하는 경우의 수 합.

구현 전략
* 1-based 인덱스: 입력 격자를 1부터 시작하도록 맞춤.
* 이동 체크 함수: 각 방향별 이동 가능 여부를 확인.
* DP 배열 채우기: 격자를 순회하며 가능한 이동마다 값을 갱신.
* 효율성: N이 작아 (최대 16) 완전 탐색 대신 DP로 O(N^2) 해결 가능.

코드 설명
1. 이동 가능 여부 확인 (check)
* y, x: 현재 위치.
* d: 방향 (0: 가로, 1: 대각선, 2: 세로).
* 가로/세로: (y,x)가 범위 내이고 벽(1)이 없으면 True.
* 대각선: (y,x), (y-1,x), (y,x-1) 모두 범위 내이고 벽이 없으면 True.
2. 입력 처리
* n: 집 크기 (3 ≤ N ≤ 16).
* a: N×N 집 상태, 0-based → 1-based로 맞추기 위해 0 행/열 추가.
* dp: 3D DP 배열 [y][x][방향], 방향별 도달 방법 수 저장.
3. DP 초기화
* dp[1][2][0] = 1: 시작점 (1,1)에서 (1,2)로 가로로 놓임.
4. DP 계산
* 각 칸 (i,j)에서:
    * 가로(0): 오른쪽(0), 대각선(1)으로 이동 가능.
    * 세로(2): 아래(2), 대각선(1)으로 이동 가능.
    * 대각선(1): 오른쪽(0), 아래(2), 대각선(1)으로 이동 가능.
* 조건 체크 후 dp 값 누적.
5. 결과 출력
* ret: (n,n)에 가로, 세로, 대각선으로 도달하는 경우의 수 합.

문제 분석
* 문제: 백준 17070 "파이프 옮기기 1".
* 입력: N, N×N 집 상태 (0: 빈 칸, 1: 벽).
* 출력: (1,1)에서 (N,N)까지 파이프 이동 방법 수.
* 조건: 가로, 세로, 대각선 이동 가능, 벽 피해야 함.

시간 복잡도
* DP 계산: O(n^2) 칸, 각 칸에서 O(1) 체크.
* 총합: O(n^2) (N ≤ 16, ≈ 256), 1초 내 충분.

결론
* 정확성: DP로 방향별 경로 수 계산, 문제 조건 충족.
* 효율성: 시간 O(n^2), 공간 O(n^2).
* 아이디어: 파이프 상태를 방향별로 관리하며 점화식으로 해결.
"""