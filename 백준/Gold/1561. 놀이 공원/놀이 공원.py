# 입력 처리
n, m = map(int, input().split())
a = list(map(int, input().split()))

# 초기 설정
MAX_N = 60000000004  # 최대 시간 상한
lo, hi = 0, MAX_N
ret = 0  # 최소 시간

# 특수 경우: N <= M
if n <= m:
    print(n)
    exit()

# 시간 내에 탈 수 있는 아이 수 체크
def check(mid):
    temp = m  # 초기 탑승 인원 (0분에 M명)
    for i in range(m):
        temp += mid // a[i]  # 각 놀이기구가 mid 시간 동안 태운 인원
    return temp >= n  # N명 이상 탈 수 있는지

# 이진 탐색으로 최소 시간 찾기
while lo <= hi:
    mid = (lo + hi) // 2
    if check(mid):  # N명 이상 탈 수 있으면 더 작은 시간 탐색
        ret = mid
        hi = mid - 1
    else:           # N명 못 타면 더 큰 시간 탐색
        lo = mid + 1

# ret-1 시간까지 탄 인원 계산
temp = m
for i in range(m):
    temp += (ret - 1) // a[i]

# ret 시간에 마지막 아이가 탄 놀이기구 찾기
for i in range(m):
    if ret % a[i] == 0:  # 해당 놀이기구가 새로 태울 수 있는 시점
        temp += 1
    if temp == n:       # N번째 아이가 타는 순간
        print(i + 1)    # 1-based 인덱스 출력
        break
"""
코드 설명
1. 입력 처리
* 입력:
    * n, m: 아이 수 (1 ≤ N ≤ 2×10^9), 놀이기구 수 (1 ≤ M ≤ 10,000).
    * a: M개 놀이기구의 운행 시간 리스트 (1 ≤ a[i] ≤ 30).
2. 초기 설정
* MAX_N: 최대 시간 상한 (60,000,000,004, 충분히 큰 값).
* lo, hi: 이진 탐색 범위 (0 ~ MAX_N).
* ret: 최소 시간 저장.
3. 특수 경우 처리
* if n <= m: 아이 수가 놀이기구 수 이하면, 모든 아이가 0분에 바로 탐 → n 출력 후 종료.
4. 시간 체크 (check 함수)
* 역할: 주어진 시간 mid에 N명 이상 탈 수 있는지 확인.
* 흐름:
    * temp = m: 0분에 M명 탑승.
    * 각 놀이기구: mid // a[i]로 해당 시간 동안 태운 인원 추가.
    * return temp >= n: N명 이상인지 반환.
5. 이진 탐색
* 역할: N명을 태우는 최소 시간(ret) 탐색.
* 흐름:
    * while lo <= hi: 범위 내 반복.
        * mid = (lo + hi) // 2: 중간값 계산.
        * check(mid):
            * True: N명 이상 가능 → ret = mid, 더 작은 시간 탐색 (hi = mid - 1).
            * False: N명 미만 → 더 큰 시간 탐색 (lo = mid + 1).
6. 마지막 아이의 놀이기구 찾기
* temp = m: ret-1 시간까지 탄 인원 계산.
    * 각 놀이기구: (ret - 1) // a[i] 추가.
* ret 시간에 새로 타는 아이 체크:
    * ret % a[i] == 0: 해당 놀이기구가 새 탑승 시작 시점.
    * temp += 1: 탑승 인원 증가.
    * temp == n: N번째 아이가 타는 순간 → 놀이기구 번호(i + 1) 출력.
7. 결과 출력
* 마지막 아이가 탄 놀이기구 번호 출력 (1-based).

문제 분석
* 문제: 백준 1561 "놀이 공원".
* 입력:
    * N, M: 아이 수, 놀이기구 수.
    * M개의 운행 시간.
* 조건:
    * 각 놀이기구는 a[i]분마다 한 명 태움.
    * N명을 태우는 최소 시간 후, 마지막 아이가 탄 놀이기구 번호 구하기.
* 출력: 마지막 아이의 놀이기구 번호.

시간 복잡도
* 입력: O(M) (≈ 10^4).
* 이진 탐색:
    * 범위: log(MAX_N) (≈ 36).
    * check: O(M) per 호출.
    * 총합: O(M log(10^10)) (≈ 3.6×10^5).
* 마지막 계산: O(M) (≈ 10^4).
* 총합: O(M log(10^10)).
* 결과: 2초 내 충분 (10^8 대비 여유).

공간 복잡도
* a: O(M) ≈ 40KB (M ≤ 10^4).
* 총합: 약 40KB (128MB 내 여유).

결론
* 정확성: C++ 코드와 동일한 로직, 샘플 통과.
* 효율성: 시간 O(M log(10^10)), 공간 O(M)으로 최적.
* 특징:
    * 이진 탐색으로 최소 시간 탐색.
    * 마지막 단계에서 N번째 아이의 놀이기구 계산.
* 검증: N, M 범위 내 효율적 동작.
"""