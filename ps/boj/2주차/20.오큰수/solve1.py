import sys
from collections import deque
ip, op = sys.stdin, sys.stdout  # 입출력 설정

n = int(ip.readline().rstrip())  # 수열 길이
a = list(map(int, ip.readline().rstrip().split()))  # 수열
ret = [-1] * n  # 오큰수 결과, 초기값 -1
stk = deque()  # 인덱스 스택

for i in range(n):
    while stk and a[stk[-1]] < a[i]:  # 현재 원소가 스택 top보다 크면
        ret[stk.pop()] = a[i]  # top의 오큰수는 현재 원소
    stk.append(i)  # 현재 인덱스 추가

print(*ret)  # 결과 출력
"""
문제 접근 방법과 아이디어
문제 이해
* 목표: 수열의 각 원소에 대해 오른쪽에 있는 첫 번째로 큰 수(오큰수)를 찾기.
* 조건:
    * 수열 길이: N (1 ≤ N ≤ 1,000,000).
    * 원소: 1 ≤ A[i] ≤ 1,000,000.
    * 오큰수가 없으면 -1.
* 출력: 각 원소의 오큰수 (공백 구분).
접근 아이디어
* 스택 활용:
    * 스택에 인덱스를 저장, 해당 원소의 오큰수를 아직 못 찾은 상태 유지.
    * 새 원소가 스택의 top 원소보다 크면, top의 오큰수는 새 원소.
    * 스택에서 pop하며 오큰수 기록, 새 인덱스 push.
* 단조 스택:
    * 스택은 단조 감소(원소 값 기준) 유지.
    * 큰 원소가 나타나면 스택에서 작은 원소들 제거.
* 구현 전략:
    * 수열을 한 번 순회.
    * 스택으로 오큰수 효율적으로 계산.
    * 남은 스택 원소는 오큰수 없음(-1).
1. 입력 처리
* ip, op = sys.stdin, sys.stdout: 빠른 입출력.
* n: 수열 길이.
* a: 수열 원소 리스트.
* ret: 오큰수 저장 배열, 초기값 -1.
* stk: 인덱스를 저장하는 deque.
2. 오큰수 계산
* for i in range(n): 수열 각 원소 순회.
    * while stk and a[stk[-1]] < a[i]:
        * 스택이 비어 있지 않고, 스택 top의 원소(a[stk[-1]])가 현재 원소(a[i])보다 작으면:
            * ret[stk.pop()] = a[i]: top 인덱스의 오큰수를 현재 원소로 설정.
    * stk.append(i): 현재 인덱스를 스택에 추가.
3. 출력
* print(*ret): 오큰수 배열을 공백 구분으로 출력.
    * 스택에 남은 인덱스는 오큰수 없음 → -1 유지.

문제 분석
* 문제: 백준 17298 "오큰수".
* 입력: N, N개의 수열.
* 출력: 각 원소의 오큰수 (-1 if none).
* 조건: 오른쪽 첫 번째 큰 수.

시간 복잡도
* 각 원소: 스택에 최대 1번 push/pop.
* 총합: O(N) (N ≤ 10^6, ≈ 10^6), 1초 내 충분.
"""