n, m = map(int, input().split())
j = int(input())
l, ret = 1, 0
for _ in range(j):
    r = l + m  - 1
    pos = int(input())
    if l <= pos <= r: continue
    elif pos < l:
        ret += (l - pos)
        l = pos
    elif pos > r:
        ret += (pos - r)
        l += (pos - r)
print(ret)

"""
문제 접근 방법과 아이디어
문제 이해
* 목표: 바구니를 이동하며 사과를 모두 받는 데 필요한 최소 이동 거리 구하기.
* 조건:
    * 화면 크기: N (1 ≤ N ≤ 20).
    * 바구니 크기: M (1 ≤ M ≤ N).
    * 사과 개수: J (1 ≤ J ≤ 20).
    * 사과 위치: 1 ≤ pos ≤ N.
    * 바구니는 좌우로만 이동 가능.
* 출력: 최소 이동 거리.
접근 아이디어
* 그리디 선택:
    * 각 사과 위치에 대해 바구니가 이미 커버할 수 있으면 이동 불필요.
    * 커버하지 못하면 최소한으로 이동해 사과를 포함하도록 조정.
* 상태 정의:
    * l: 바구니의 왼쪽 끝 위치.
    * r: 바구니의 오른쪽 끝 위치 (l + m - 1).
    * ret: 총 이동 거리.
* 구현 전략:
    * 초기 바구니: (1, M).
    * 사과 위치(pos)에 따라:
        * l <= pos <= r: 이동 불필요.
        * pos < l: 왼쪽으로 이동.
        * pos > r: 오른쪽으로 이동.
    * 이동 거리 누적.

1. 입력 처리
* n, m: 화면 크기(N), 바구니 크기(M).
* j: 사과 개수.
* l: 바구니 왼쪽 끝, 초기값 1.
* ret: 총 이동 거리, 초기값 0.
2. 사과 위치 처리
* J번 반복:
    * r = l + m - 1: 바구니 오른쪽 끝 계산 (크기 M).
    * pos: 사과 위치 입력.
    * 조건 분기:
        * l <= pos <= r: 사과가 바구니 범위 내 → 이동 불필요, 스킵.
        * pos < l: 사과가 바구니 왼쪽:
            * ret += (l - pos): 왼쪽으로 이동한 거리 추가.
            * l = pos: 바구니 왼쪽 끝을 사과 위치로 이동.
        * pos > r: 사과가 바구니 오른쪽:
            * ret += (pos - r): 오른쪽으로 이동한 거리 추가.
            * l += (pos - r): 바구니 왼쪽 끝을 이동.
3. 출력
* ret: 최소 이동 거리 출력.

문제 분석
* 문제: 백준 2828 "사과 담기 게임".
* 입력: N, M, J, J개의 사과 위치.
* 출력: 최소 이동 거리.
* 조건: 바구니 크기 M, 좌우 이동.

시간 복잡도
* 사과 처리: O(J).
* 총합: O(J) (J ≤ 20, ≈ 20), 1초 내 충분.

결론
* 정확성: 그리디로 최소 이동 거리 정확히 계산.
* 효율성: 시간 O(J), 공간 O(1).
* 아이디어: 바구니 위치 조정으로 최적 이동 구현.

"""