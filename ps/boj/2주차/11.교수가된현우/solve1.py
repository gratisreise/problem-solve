t = int(input())  # 테스트 케이스 수

for _ in range(t):
    n = int(input())  # 입력 N
    idx, cnt5 = 1, 0  # 5의 제곱 인덱스, 5의 개수
    while 5 ** idx <= n:  # 5^idx가 N 이하일 때
        cnt5 += n // (5**idx)  # N을 5^idx로 나눈 몫 추가
        idx += 1  # 다음 제곱수
    print(cnt5)  # 결과 출력

"""
문제 접근 방법과 아이디어
문제 이해
* 목표: N!의 끝에 붙는 0의 개수 출력.
* 조건:
    * 테스트 케이스: T (1 ≤ T ≤ 1000).
    * N: 0 ≤ N ≤ 10^9.
* 출력: 각 테스트 케이스별 0의 개수.
접근 아이디어
* 0의 개수:
    * N!의 끝에 붙는 0은 10의 배수로 나타남.
    * 10 = 2 × 5, 2의 개수는 항상 5의 개수보다 많으므로 5의 개수만 세면 됨.
* 5의 개수 계산:
    * N!에서 5의 지수 = ⌊N/5⌋ + ⌊N/25⌋ + ⌊N/125⌋ + ... (5^k ≤ N인 모든 k).
    * 각 ⌊N/5^k⌋는 5^k로 나누어지는 수의 개수.
* 구현 전략:
    * 5의 제곱수(5, 25, 125, ...)로 N을 나눈 몫을 누적.
    * N ≤ 10^9이므로 5^12 ≈ 244140625 ≤ 10^9까지 계산.

1. 입력 처리
* t: 테스트 케이스 수.
* for _ in range(t): T번 반복.
2. 5의 개수 계산
* n: 각 테스트 케이스의 입력값.
* idx, cnt5 = 1, 0: 5의 제곱 인덱스(시작 5^1), 5의 개수 초기화.
* while 5 ** idx <= n: 5^idx가 N 이하인 동안:
    * cnt5 += n // (5**idx): N을 5^idx로 나눈 몫(해당 제곱수의 기여도).
    * idx += 1: 다음 제곱수로 이동.
3. 출력
* print(cnt5): N!에서 5의 지수(끝 0의 개수) 출력.

문제 분석
* 문제: 백준 3474 "교수가 된 현우".
* 입력: T, T개의 N.
* 출력: 각 N!의 끝 0 개수.
* 조건: 2의 개수 > 5의 개수, 5의 지수만 계산.

시간 복잡도
* 각 테스트 케이스:
    * while 루프: 최대 log_5(10^9) ≈ 12번.
    * 연산: O(log N).
* 총합: O(T * log N) (T ≤ 1000, log N ≈ 12, ≈ 10^4), 1초 내 충분.
"""