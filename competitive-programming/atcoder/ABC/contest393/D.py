import sys

n = int(input().strip())
s = input().strip()

c1 = s.count('1')
now = 0
ans = 0

for c in s:
    if c == '0':
        ans += min(now, c1 - now)
    else:
        now += 1

print(ans)


"""
기준점을 1의 이동이 아니라
0을 기준으로 좌우의 1의 갯수를 카운팅하여 이동방향과 거리 설정

S는 최소 하나의 1은 가지고 있다
모든 1이 연속되도록 만드는 최소의 swap
swap = (i, i+1)
문자열 S에 있는 각 '0'에 대해 다음을 고려한다.
- l: 해당 '0'의 왼쪽에 있는 '1'의 갯수
- r: 해당 '0'의 오른쪽에 잇는 '1'의 갯수
만약 l < r라면, 해당 '0'을 왼쪽으로 이동하는 것이 더 효율적이다. == 왼쪽 1이 오른쪽으로 이동
반대로, l > r라면, 해당 '0'을 오른쪽으로 이동하는 것이 더 효율적이다. == 오른쪽 1이 왼쪽으로 이동
따라서, 각 '0'에 대해 min(l,r)값을 더한 값이 최적의 이동 횟수가 된다.
"""