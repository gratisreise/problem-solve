from collections import deque
n, m = map(int, input().split())
dy, dx = [0, 1, 0, -1], [-1, 0, 1, 0]  # 상, 우, 하, 좌
mp, vis = []*n, [[0]*m for _ in range(n)]  # 미로, 방문 배열
q = deque()

# 미로 입력
for _ in range(n):
    mp.append(list(map(int, input())))

# BFS 초기화
vis[0][0] = 1  # 시작점 방문 (거리 1)
q.append((0, 0))  # 시작점 큐에 추가

# BFS 탐색
while q:
    y, x = q.popleft()  # 현재 위치
    for d in range(4):  # 4방향 탐색
        ny, nx = y + dy[d], x + dx[d]  # 다음 위치
        if ny < 0 or nx < 0 or ny >= n or nx >= m:  # 범위 체크
            continue
        if mp[ny][nx] == 0 or vis[ny][nx]:  # 이동 불가 or 이미 방문
            continue
        vis[ny][nx] = vis[y][x] + 1  # 거리 갱신
        q.append((ny, nx))  # 다음 위치 큐에 추가

# 출력
print(vis[n-1][m-1])  # 목표 지점까지의 최단 거리

"""
문제 접근 방법과 아이디어
문제 이해
* 목표: (1,1)에서 (N,M)까지 이동하는 최단 경로의 길이 구하기.
* 조건:
    * 격자: N×M (2 ≤ N, M ≤ 100).
    * 0: 이동 불가, 1: 이동 가능.
    * 이동: 상하좌우 4방향.
* 출력: (N,M)에 도달하는 최소 칸 수 (시작과 끝 포함).
접근 아이디어
* BFS 선택:
    * 최단 경로를 구해야 하므로 DFS 대신 BFS 사용 (BFS는 레벨 단위로 탐색해 최단 거리 보장).
* 상태 정의:
    * vis[y][x]: (y,x)에 도달하는 데 필요한 최소 이동 횟수.
* 탐색:
    * 큐에 시작점 (0,0) 추가, 방문 표시.
    * 4방향 탐색하며 이동 가능한 칸(1) 방문, 거리 갱신.
* 기저 조건:
    * (N-1,M-1) 도달 시 vis[n-1][m-1] 반환.
* 구현 전략:
    * deque로 BFS 구현.
    * 방문 배열로 거리 기록 겸 중복 방지.

1. 입력 처리
* n, m: 격자 크기(N, M).
* dy, dx: 4방향 이동 벡터 (상, 우, 하, 좌).
* mp: N×M 미로, 각 행을 리스트로 입력 (0/1로 구성).
* vis: 방문 및 거리 저장 배열, 초기값 0.
* q: BFS용 deque.
2. 미로 입력
* for _ in range(n): N줄 입력.
* list(map(int, input())): 문자열을 숫자 리스트로 변환 (예: "101" → [1, 0, 1]).
3. BFS 초기화
* vis[0][0] = 1: 시작점 (0,0) 방문, 거리 1로 설정 (시작 포함).
* q.append((0, 0)): 시작점 큐에 추가.
4. BFS 탐색
* while q: 큐가 빌 때까지 반복.
    * y, x = q.popleft(): 현재 위치 꺼냄.
    * for d in range(4): 4방향 탐색.
        * ny, nx: 다음 위치 계산.
        * 범위 체크: 격자 밖이면 스킵.
        * 이동 불가(mp[ny][nx] == 0) 또는 방문済(vis[ny][nx])면 스킵.
        * vis[ny][nx] = vis[y][x] + 1: 현재 거리 + 1로 갱신.
        * q.append((ny, nx)): 다음 위치 큐에 추가.
5. 출력
* vis[n-1][m-1]: (N-1,M-1)까지의 최단 거리 출력.

문제 분석
* 문제: 백준 2178 "미로 탐색".
* 입력: N, M, N×M 미로 (0/1).
* 출력: (1,1)에서 (N,M)까지 최단 경로 길이.
* 조건: 4방향 이동, 1만 이동 가능.

시간 복잡도
* BFS: 각 칸 최대 1번 방문 → O(N * M).
* 총합: O(N * M) (N, M ≤ 100, ≈ 10^4), 1초 내 충분.


결론
* 정확성: BFS로 최단 경로 보장.
* 효율성: 시간 O(N * M), 공간 O(N * M).
* 아이디어: 방문 배열로 거리 계산, deque로 효율적 탐색.

"""