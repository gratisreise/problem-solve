h, w = map(int, input().split())  # 격자 크기
ret = [[-1] * w for _ in range(h)]  # 결과 격자
a = []  # 입력 격자

# 격자 입력
for _ in range(h):
    a.append(list(input()))

# 구름 도달 시간 계산
for i in range(h):
    for j in range(w):
        if a[i][j] == 'c':  # 구름 발견
            temp, cnt = j + 1, 1  # 다음 칸부터 카운트
            ret[i][j] = 0  # 구름 위치는 0분
            while temp < w and a[i][temp] == '.':  # 오른쪽으로 이동
                ret[i][temp] = cnt  # 시간 기록
                temp += 1  # 다음 칸
                cnt += 1  # 시간 증가

# 출력
for arr in ret:
    print(' '.join(map(str, arr)))

"""
문제 접근 방법과 아이디어
문제 이해
* 목표: 각 칸이 구름에 덮이는 시간(또는 덮이지 않으면 -1)을 계산.
* 조건:
    * 격자: H×W (1 ≤ H, W ≤ 100).
    * 각 칸: '.' (빈 칸) 또는 'c' (구름).
    * 구름은 매 분 오른쪽으로 이동.
* 출력: H×W 격자, 각 칸의 구름 도달 시간 (공백 구분).
접근 아이디어
* 시뮬레이션:
    * 각 행에서 구름('c')을 기준으로 오른쪽으로 시간 계산.
    * 'c'가 없으면 해당 칸은 -1.
* 상태 정의:
    * ret[y][x]: (y,x)에 구름이 도달하는 시간 (-1: 도달 불가).
* 구현 전략:
    * 격자 입력 후 각 행 순회.
    * 'c' 발견 시 오른쪽으로 '.'이 연속된 동안 시간 증가.
1. 입력 처리
* h, w: 격자 세로(H), 가로(W).
* ret: H×W 결과 격자, 초기값 -1 (구름 미도달).
* a: H×W 입력 격자, 각 행을 문자열 리스트로 입력.
2. 구름 도달 시간 계산
* for i in range(h): 각 행 순회.
    * for j in range(w): 각 열 순회.
        * if a[i][j] == 'c': 구름 발견:
            * ret[i][j] = 0: 구름 위치는 0분.
            * temp = j + 1: 다음 칸 인덱스.
            * cnt = 1: 다음 칸부터 시간.
            * while temp < w and a[i][temp] == '.': 오른쪽으로 '.' 연속 시:
                * ret[i][temp] = cnt: 시간 기록.
                * temp += 1: 다음 칸 이동.
                * cnt += 1: 시간 증가.
3. 출력
* for arr in ret: 결과 격자 행별 순회.
* ' '.join(map(str, arr)): 정수 리스트를 공백 구분 문자열로 변환 후 출력.

문제 분석
* 문제: 백준 10709 "기상캐스터".
* 입력: H, W, H×W 격자 ('.' 또는 'c').
* 출력: 각 칸의 구름 도달 시간 (-1: 미도달).
* 조건: 구름은 오른쪽으로 이동.

시간 복잡도
* 격자 순회: O(H * W).
* 각 'c'마다 오른쪽 탐색: 최악 O(W).
* 총합: O(H * W) (H, W ≤ 100, ≈ 10^4), 1초 내 충분.

결론
* 정확성: 구름 이동 시간 정확히 계산.
* 효율성: 시간 O(H * W), 공간 O(H * W).
* 아이디어: 각 행에서 'c'를 기준으로 오른쪽 시간 계산.
"""