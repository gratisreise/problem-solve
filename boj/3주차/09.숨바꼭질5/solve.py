from collections import deque
import sys

input = sys.stdin.readline

# 입력 처리
N, K = map(int, input().split())
MAX = 500001  # 최대 위치 범위

# 방문 배열: [짝수 시간, 홀수 시간]에 도달한 최소 시간
visited = [[-1] * 2 for _ in range(MAX)]

# BFS
queue = deque([(N, 0)])  # (위치, 시간)
visited[N][0] = 0  # 초기 위치, 시간 0

while queue:
    x, t = queue.popleft()
    
    # 동생의 현재 위치 계산
    delta = t * (t + 1) // 2  # 1+2+...+t
    if K + delta > 500000:  # 동생 위치가 범위 초과
        break
    if visited[K + delta][t % 2] != -1:  # 동생 위치 방문 완료
        print(t)
        sys.exit(0)
    
    # 이동: X-1, X+1, 2*X
    for nx in (x-1, x+1, 2*x):
        if 0 <= nx < MAX and visited[nx][(t+1) % 2] == -1:
            visited[nx][(t+1) % 2] = t + 1
            queue.append((nx, t + 1))

# 동생을 못 찾으면 -1
print(-1)
"""
문제 접근 방법과 아이디어
문제 이해
* 목표: 수빈이(위치 N)가 동생(위치 K, 시간 t에 K+t(t+1)/2)에 도달하는 최소 시간 구하기.
* 조건:
    * 위치: 0 ≤ N, K ≤ 500,000.
    * 수빈이 이동:
        * X-1, X+1, 2*X: 1초 소요.
    * 동생 이동:
        * 시간 t일 때 위치 = K + t(t+1)/2 (1+2+...+t).
    * 동생 위치는 시간 t에 따라 증가.
* 출력:
    * 도달 가능: 최소 시간.
    * 불가능: -1.
접근 아이디어
* BFS:
    * 수빈이의 최단 시간 경로 탐색 → BFS 적합.
    * 상태: (위치 X, 시간 t).
    * 동생의 위치는 시간 t에 따라 결정적(K + t(t+1)/2).
* 주기성 활용:
    * 동생 위치가 시간에 따라 증가하므로, 수빈이가 특정 위치에 도달한 시간의 홀짝(짝수/홀수)을 고려.
    * 방문 배열을 [위치][시간%2]로 관리 (짝수 시간, 홀수 시간 분리).
    * 동일 위치에서 시간 차이가 2인 경우 같은 홀짝 패턴 → 재방문 불필요.
* 상태 관리:
    * visited: [위치][시간%2]로 최소 도착 시간 저장.
    * queue: BFS 큐, (위치, 시간) 저장.
* 구현 전략:
    * BFS로 수빈이의 이동 탐색.
    * 각 시간 t에서 동생 위치(K + t(t+1)/2) 확인.
    * 동생 위치가 이미 방문된 경우 최소 시간 출력.
    * 범위 초과 또는 도달 불가 시 -1.
1. 입력 처리
* input = sys.stdin.readline: 빠른 입력.
* N, K: 수빈이 위치(N), 동생 초기 위치(K).
* MAX = 500001: 위치 범위 (0~500,000).
* visited = [[-1] * 2 for _ in range(MAX)]: 방문 배열, [위치][시간%2], -1은 미방문.
2. BFS 초기화
* queue = deque([(N, 0)]): BFS 큐, 초기 상태 (위치 N, 시간 0).
* visited[N][0] = 0: 초기 위치, 짝수 시간(0)에 방문.
3. BFS
* while queue:
    * x, t = queue.popleft(): 현재 위치(x), 시간(t).
    * 동생 위치 계산:
        * delta = t * (t + 1) // 2: 시간 t까지의 이동 거리 (1+2+...+t).
        * if K + delta > 500000: 동생 위치 범위 초과 → 종료.
        * if visited[K + delta][t % 2] != -1: 동생 위치에 t의 홀짝 시간에 이미 방문:
            * print(t): 현재 시간 출력.
            * sys.exit(0): 종료.
    * 이동: for nx in (x-1, x+1, 2*x):
        * 0 <= nx < MAX and visited[nx][(t+1) % 2] == -1: 범위 내, 다음 시간의 홀짝 미방문:
            * visited[nx][(t+1) % 2] = t + 1: 방문 시간 기록.
            * queue.append((nx, t + 1)): 다음 상태 추가.
4. 출력
* BFS 종료 후 도달 불가: print(-1).

문제 분석
* 문제: 백준 17071 "숨바꼭질 5".
* 입력: N, K.
* 출력: 최소 도달 시간 또는 -1.
* 조건: 수빈이(X-1, X+1, 2*X), 동생(K + t(t+1)/2).

시간 복잡도
* 상태: 위치 (0~500,000) × 홀짝 (2).
* 각 상태에서 이동: 3가지 (X-1, X+1, 2*X).
* BFS: O(MAX * 2 * 3) ≈ O(3,000,000), 1초 내 충분.

"""